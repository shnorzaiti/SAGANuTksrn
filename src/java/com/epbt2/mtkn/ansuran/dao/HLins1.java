package com.epbt2.mtkn.ansuran.dao;


import java.io.*;
import java.sql.*;
import java.util.*;
import java.math.*;

 /**
  * HLins1 Value Object.
  * This class is value object representing database table hlins1
  * This class is intented to be used together with associated Dao object.
  */

 /**
  * This sourcecode has been generated by FREE DaoGen generator version 2.4.1.
  * The usage of generated code is restricted to OpenSource software projects
  * only. DaoGen is available in http://titaniclinux.net/daogen/
  * It has been programmed by Tuomo Lukka, Tuomo.Lukka@iki.fi
  *
  * DaoGen license: The following DaoGen generated source code is licensed
  * under the terms of GNU GPL license. The full text for license is available
  * in GNU project's pages: http://www.gnu.org/copyleft/gpl.html
  *
  * If you wish to use the DaoGen generator to produce code for closed-source
  * commercial applications, you must pay the lisence fee. The price is
  * 5 USD or 5 Eur for each database table, you are generating code for.
  * (That includes unlimited amount of iterations with all supported languages
  * for each database table you are paying for.) Send mail to
  * "Tuomo.Lukka@iki.fi" for more information. Thank you!
  */



public class HLins1 implements Cloneable, Serializable {

    /** 
     * Persistent Instance variables. This data is directly 
     * mapped to the columns of database table.
     */
    private String in1Akaun;
    private String in1Jmseq;
    private String in1Amaun;
    private String in1Statf;
    private String in1Stang;
    private String in1Nopek;
    private String in1Tdate;
    private String in1Onama;
    private String in1Maddr;
    private String in1Pcnme;



    /** 
     * Constructors. DaoGen generates two constructors by default.
     * The first one takes no arguments and provides the most simple
     * way to create object instance. The another one takes one
     * argument, which is the primary key of the corresponding table.
     */

    public HLins1 () {

    }

    public HLins1 (String in1AkaunIn) {

          this.in1Akaun = in1AkaunIn;

    }


    /** 
     * Get- and Set-methods for persistent variables. The default
     * behaviour does not make any checks against malformed data,
     * so these might require some manual additions.
     */

    public String getIn1Akaun() {
          return this.in1Akaun;
    }
    public void setIn1Akaun(String in1AkaunIn) {
          this.in1Akaun = in1AkaunIn;
    }

    public String getIn1Jmseq() {
          return this.in1Jmseq;
    }
    public void setIn1Jmseq(String in1JmseqIn) {
          this.in1Jmseq = in1JmseqIn;
    }

    public String getIn1Amaun() {
          return this.in1Amaun;
    }
    public void setIn1Amaun(String in1AmaunIn) {
          this.in1Amaun = in1AmaunIn;
    }

    public String getIn1Statf() {
          return this.in1Statf;
    }
    public void setIn1Statf(String in1StatfIn) {
          this.in1Statf = in1StatfIn;
    }

    public String getIn1Stang() {
          return this.in1Stang;
    }
    public void setIn1Stang(String in1StangIn) {
          this.in1Stang = in1StangIn;
    }

    public String getIn1Nopek() {
          return this.in1Nopek;
    }
    public void setIn1Nopek(String in1NopekIn) {
          this.in1Nopek = in1NopekIn;
    }

    public String getIn1Tdate() {
          return this.in1Tdate;
    }
    public void setIn1Tdate(String in1TdateIn) {
          this.in1Tdate = in1TdateIn;
    }

    public String getIn1Onama() {
          return this.in1Onama;
    }
    public void setIn1Onama(String in1OnamaIn) {
          this.in1Onama = in1OnamaIn;
    }

    public String getIn1Maddr() {
          return this.in1Maddr;
    }
    public void setIn1Maddr(String in1MaddrIn) {
          this.in1Maddr = in1MaddrIn;
    }

    public String getIn1Pcnme() {
          return this.in1Pcnme;
    }
    public void setIn1Pcnme(String in1PcnmeIn) {
          this.in1Pcnme = in1PcnmeIn;
    }



    /** 
     * setAll allows to set all persistent variables in one method call.
     * This is useful, when all data is available and it is needed to 
     * set the initial state of this object. Note that this method will
     * directly modify instance variales, without going trough the 
     * individual set-methods.
     */

    public void setAll(String in1AkaunIn,
          String in1JmseqIn,
          String in1AmaunIn,
          String in1StatfIn,
          String in1StangIn,
          String in1NopekIn,
          String in1TdateIn,
          String in1OnamaIn,
          String in1MaddrIn,
          String in1PcnmeIn) {
          this.in1Akaun = in1AkaunIn;
          this.in1Jmseq = in1JmseqIn;
          this.in1Amaun = in1AmaunIn;
          this.in1Statf = in1StatfIn;
          this.in1Stang = in1StangIn;
          this.in1Nopek = in1NopekIn;
          this.in1Tdate = in1TdateIn;
          this.in1Onama = in1OnamaIn;
          this.in1Maddr = in1MaddrIn;
          this.in1Pcnme = in1PcnmeIn;
    }


    /** 
     * hasEqualMapping-method will compare two HLins1 instances
     * and return true if they contain same values in all persistent instance 
     * variables. If hasEqualMapping returns true, it does not mean the objects
     * are the same instance. However it does mean that in that moment, they 
     * are mapped to the same row in database.
     */
    public boolean hasEqualMapping(HLins1 valueObject) {

          if (this.in1Akaun == null) {
                    if (valueObject.getIn1Akaun() != null)
                           return(false);
          } else if (!this.in1Akaun.equals(valueObject.getIn1Akaun())) {
                    return(false);
          }
          if (this.in1Jmseq == null) {
                    if (valueObject.getIn1Jmseq() != null)
                           return(false);
          } else if (!this.in1Jmseq.equals(valueObject.getIn1Jmseq())) {
                    return(false);
          }
          if (this.in1Amaun == null) {
                    if (valueObject.getIn1Amaun() != null)
                           return(false);
          } else if (!this.in1Amaun.equals(valueObject.getIn1Amaun())) {
                    return(false);
          }
          if (this.in1Statf == null) {
                    if (valueObject.getIn1Statf() != null)
                           return(false);
          } else if (!this.in1Statf.equals(valueObject.getIn1Statf())) {
                    return(false);
          }
          if (this.in1Stang == null) {
                    if (valueObject.getIn1Stang() != null)
                           return(false);
          } else if (!this.in1Stang.equals(valueObject.getIn1Stang())) {
                    return(false);
          }
          if (this.in1Nopek == null) {
                    if (valueObject.getIn1Nopek() != null)
                           return(false);
          } else if (!this.in1Nopek.equals(valueObject.getIn1Nopek())) {
                    return(false);
          }
          if (this.in1Tdate == null) {
                    if (valueObject.getIn1Tdate() != null)
                           return(false);
          } else if (!this.in1Tdate.equals(valueObject.getIn1Tdate())) {
                    return(false);
          }
          if (this.in1Onama == null) {
                    if (valueObject.getIn1Onama() != null)
                           return(false);
          } else if (!this.in1Onama.equals(valueObject.getIn1Onama())) {
                    return(false);
          }
          if (this.in1Maddr == null) {
                    if (valueObject.getIn1Maddr() != null)
                           return(false);
          } else if (!this.in1Maddr.equals(valueObject.getIn1Maddr())) {
                    return(false);
          }
          if (this.in1Pcnme == null) {
                    if (valueObject.getIn1Pcnme() != null)
                           return(false);
          } else if (!this.in1Pcnme.equals(valueObject.getIn1Pcnme())) {
                    return(false);
          }

          return true;
    }



    /**
     * toString will return String object representing the state of this 
     * valueObject. This is useful during application development, and 
     * possibly when application is writing object states in textlog.
     */
    public String toString() {
        StringBuffer out = new StringBuffer(this.getDaogenVersion());
        out.append("\nclass HLins1, mapping to table hlins1\n");
        out.append("Persistent attributes: \n"); 
        out.append("in1Akaun = " + this.in1Akaun + "\n"); 
        out.append("in1Jmseq = " + this.in1Jmseq + "\n"); 
        out.append("in1Amaun = " + this.in1Amaun + "\n"); 
        out.append("in1Statf = " + this.in1Statf + "\n"); 
        out.append("in1Stang = " + this.in1Stang + "\n"); 
        out.append("in1Nopek = " + this.in1Nopek + "\n"); 
        out.append("in1Tdate = " + this.in1Tdate + "\n"); 
        out.append("in1Onama = " + this.in1Onama + "\n"); 
        out.append("in1Maddr = " + this.in1Maddr + "\n"); 
        out.append("in1Pcnme = " + this.in1Pcnme + "\n"); 
        return out.toString();
    }


    /**
     * Clone will return identical deep copy of this valueObject.
     * Note, that this method is different than the clone() which
     * is defined in java.lang.Object. Here, the retuned cloned object
     * will also have all its attributes cloned.
     */
    public Object clone() {
        HLins1 cloned = new HLins1();

        if (this.in1Akaun != null)
             cloned.setIn1Akaun(new String(this.in1Akaun)); 
        if (this.in1Jmseq != null)
             cloned.setIn1Jmseq(new String(this.in1Jmseq)); 
        if (this.in1Amaun != null)
             cloned.setIn1Amaun(new String(this.in1Amaun)); 
        if (this.in1Statf != null)
             cloned.setIn1Statf(new String(this.in1Statf)); 
        if (this.in1Stang != null)
             cloned.setIn1Stang(new String(this.in1Stang)); 
        if (this.in1Nopek != null)
             cloned.setIn1Nopek(new String(this.in1Nopek)); 
        if (this.in1Tdate != null)
             cloned.setIn1Tdate(new String(this.in1Tdate)); 
        if (this.in1Onama != null)
             cloned.setIn1Onama(new String(this.in1Onama)); 
        if (this.in1Maddr != null)
             cloned.setIn1Maddr(new String(this.in1Maddr)); 
        if (this.in1Pcnme != null)
             cloned.setIn1Pcnme(new String(this.in1Pcnme)); 
        return cloned;
    }



    /** 
     * getDaogenVersion will return information about
     * generator which created these sources.
     */
    public String getDaogenVersion() {
        return "DaoGen version 2.4.1";
    }

}
