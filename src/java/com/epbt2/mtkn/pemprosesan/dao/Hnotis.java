package com.epbt2.mtkn.pemprosesan.dao;

import java.io.*;
import java.sql.*;
import java.util.*;
import java.math.*;

/**
 * Hnotis Value Object. This class is value object representing database table
 * MTKN.HNOTIS This class is intented to be used together with associated Dao
 * object.
 */
/**
 * This sourcecode has been generated by FREE DaoGen generator version 2.4.1.
 * The usage of generated code is restricted to OpenSource software projects
 * only. DaoGen is available in http://titaniclinux.net/daogen/ It has been
 * programmed by Tuomo Lukka, Tuomo.Lukka@iki.fi
 *
 * DaoGen license: The following DaoGen generated source code is licensed under
 * the terms of GNU GPL license. The full text for license is available in GNU
 * project's pages: http://www.gnu.org/copyleft/gpl.html
 *
 * If you wish to use the DaoGen generator to produce code for closed-source
 * commercial applications, you must pay the lisence fee. The price is 5 USD or
 * 5 Eur for each database table, you are generating code for. (That includes
 * unlimited amount of iterations with all supported languages for each database
 * table you are paying for.) Send mail to "Tuomo.Lukka@iki.fi" for more
 * information. Thank you!
 */
public class Hnotis implements Cloneable, Serializable {

    /**
     * Persistent Instance variables. This data is directly mapped to the
     * columns of database table.
     */
    private String notStatf;
    private String notAkaun;
    private String notNonot;
    private String notTknot;
    private String notTmpoh;
    private String notAmaun;
    private String notGenap;
    private String notCtsms;
    private String notCttgk;
    private String notDnsms;
    private String notDntgk;
    private String notNtsms;
    private String notNttgk;
    private String notWrsms;
    private String notWrtgk;
    private String notAlsms;
    private String notAltgk;

    /* BYE 02/11/2016 */
    private String keter;

    public String getKeter() {
        return keter;
    }

    public void setKeter(String keter) {
        this.keter = keter;
    }

    /* BYE 02/11/2016 */
    /**
     * Constructors. DaoGen generates two constructors by default. The first one
     * takes no arguments and provides the most simple way to create object
     * instance. The another one takes one argument, which is the primary key of
     * the corresponding table.
     */
    public Hnotis() {

    }

    public Hnotis(String notStatfIn, String notAkaunIn) {

        this.notStatf = notStatfIn;
        this.notAkaun = notAkaunIn;

    }

    /**
     * Get- and Set-methods for persistent variables. The default behaviour does
     * not make any checks against malformed data, so these might require some
     * manual additions.
     */
    public String getNotStatf() {
        return this.notStatf;
    }

    public void setNotStatf(String notStatfIn) {
        this.notStatf = notStatfIn;
    }

    public String getNotAkaun() {
        return this.notAkaun;
    }

    public void setNotAkaun(String notAkaunIn) {
        this.notAkaun = notAkaunIn;
    }

    public String getNotNonot() {
        return this.notNonot;
    }

    public void setNotNonot(String notNonotIn) {
        this.notNonot = notNonotIn;
    }

    public String getNotTknot() {
        return this.notTknot;
    }

    public void setNotTknot(String notTknotIn) {
        this.notTknot = notTknotIn;
    }

    public String getNotTmpoh() {
        return this.notTmpoh;
    }

    public void setNotTmpoh(String notTmpohIn) {
        this.notTmpoh = notTmpohIn;
    }

    public String getNotAmaun() {
        return this.notAmaun;
    }

    public void setNotAmaun(String notAmaunIn) {
        this.notAmaun = notAmaunIn;
    }

    public String getNotGenap() {
        return this.notGenap;
    }

    public void setNotGenap(String notGenapIn) {
        this.notGenap = notGenapIn;
    }

    public String getNotCtsms() {
        return this.notCtsms;
    }

    public void setNotCtsms(String notCtsmsIn) {
        this.notCtsms = notCtsmsIn;
    }

    public String getNotCttgk() {
        return this.notCttgk;
    }

    public void setNotCttgk(String notCttgkIn) {
        this.notCttgk = notCttgkIn;
    }

    public String getNotDnsms() {
        return this.notDnsms;
    }

    public void setNotDnsms(String notDnsmsIn) {
        this.notDnsms = notDnsmsIn;
    }

    public String getNotDntgk() {
        return this.notDntgk;
    }

    public void setNotDntgk(String notDntgkIn) {
        this.notDntgk = notDntgkIn;
    }

    public String getNotNtsms() {
        return this.notNtsms;
    }

    public void setNotNtsms(String notNtsmsIn) {
        this.notNtsms = notNtsmsIn;
    }

    public String getNotNttgk() {
        return this.notNttgk;
    }

    public void setNotNttgk(String notNttgkIn) {
        this.notNttgk = notNttgkIn;
    }

    public String getNotWrsms() {
        return this.notWrsms;
    }

    public void setNotWrsms(String notWrsmsIn) {
        this.notWrsms = notWrsmsIn;
    }

    public String getNotWrtgk() {
        return this.notWrtgk;
    }

    public void setNotWrtgk(String notWrtgkIn) {
        this.notWrtgk = notWrtgkIn;
    }

    public String getNotAlsms() {
        return this.notAlsms;
    }

    public void setNotAlsms(String notAlsmsIn) {
        this.notAlsms = notAlsmsIn;
    }

    public String getNotAltgk() {
        return this.notAltgk;
    }

    public void setNotAltgk(String notAltgkIn) {
        this.notAltgk = notAltgkIn;
    }

    /**
     * setAll allows to set all persistent variables in one method call. This is
     * useful, when all data is available and it is needed to set the initial
     * state of this object. Note that this method will directly modify instance
     * variales, without going trough the individual set-methods.
     */
    public void setAll(String notStatfIn,
            String notAkaunIn,
            String notNonotIn,
            String notTknotIn,
            String notTmpohIn,
            String notAmaunIn,
            String notGenapIn,
            String notCtsmsIn,
            String notCttgkIn,
            String notDnsmsIn,
            String notDntgkIn,
            String notNtsmsIn,
            String notNttgkIn,
            String notWrsmsIn,
            String notWrtgkIn,
            String notAlsmsIn,
            String notAltgkIn) {
        this.notStatf = notStatfIn;
        this.notAkaun = notAkaunIn;
        this.notNonot = notNonotIn;
        this.notTknot = notTknotIn;
        this.notTmpoh = notTmpohIn;
        this.notAmaun = notAmaunIn;
        this.notGenap = notGenapIn;
        this.notCtsms = notCtsmsIn;
        this.notCttgk = notCttgkIn;
        this.notDnsms = notDnsmsIn;
        this.notDntgk = notDntgkIn;
        this.notNtsms = notNtsmsIn;
        this.notNttgk = notNttgkIn;
        this.notWrsms = notWrsmsIn;
        this.notWrtgk = notWrtgkIn;
        this.notAlsms = notAlsmsIn;
        this.notAltgk = notAltgkIn;
    }

    /**
     * hasEqualMapping-method will compare two Hnotis instances and return true
     * if they contain same values in all persistent instance variables. If
     * hasEqualMapping returns true, it does not mean the objects are the same
     * instance. However it does mean that in that moment, they are mapped to
     * the same row in database.
     */
    public boolean hasEqualMapping(Hnotis valueObject) {

        if (this.notStatf == null) {
            if (valueObject.getNotStatf() != null) {
                return (false);
            }
        } else if (!this.notStatf.equals(valueObject.getNotStatf())) {
            return (false);
        }
        if (this.notAkaun == null) {
            if (valueObject.getNotAkaun() != null) {
                return (false);
            }
        } else if (!this.notAkaun.equals(valueObject.getNotAkaun())) {
            return (false);
        }
        if (this.notNonot == null) {
            if (valueObject.getNotNonot() != null) {
                return (false);
            }
        } else if (!this.notNonot.equals(valueObject.getNotNonot())) {
            return (false);
        }
        if (this.notTknot == null) {
            if (valueObject.getNotTknot() != null) {
                return (false);
            }
        } else if (!this.notTknot.equals(valueObject.getNotTknot())) {
            return (false);
        }
        if (this.notTmpoh == null) {
            if (valueObject.getNotTmpoh() != null) {
                return (false);
            }
        } else if (!this.notTmpoh.equals(valueObject.getNotTmpoh())) {
            return (false);
        }
        if (this.notAmaun == null) {
            if (valueObject.getNotAmaun() != null) {
                return (false);
            }
        } else if (!this.notAmaun.equals(valueObject.getNotAmaun())) {
            return (false);
        }
        if (this.notGenap == null) {
            if (valueObject.getNotGenap() != null) {
                return (false);
            }
        } else if (!this.notGenap.equals(valueObject.getNotGenap())) {
            return (false);
        }
        if (this.notCtsms == null) {
            if (valueObject.getNotCtsms() != null) {
                return (false);
            }
        } else if (!this.notCtsms.equals(valueObject.getNotCtsms())) {
            return (false);
        }
        if (this.notCttgk == null) {
            if (valueObject.getNotCttgk() != null) {
                return (false);
            }
        } else if (!this.notCttgk.equals(valueObject.getNotCttgk())) {
            return (false);
        }
        if (this.notDnsms == null) {
            if (valueObject.getNotDnsms() != null) {
                return (false);
            }
        } else if (!this.notDnsms.equals(valueObject.getNotDnsms())) {
            return (false);
        }
        if (this.notDntgk == null) {
            if (valueObject.getNotDntgk() != null) {
                return (false);
            }
        } else if (!this.notDntgk.equals(valueObject.getNotDntgk())) {
            return (false);
        }
        if (this.notNtsms == null) {
            if (valueObject.getNotNtsms() != null) {
                return (false);
            }
        } else if (!this.notNtsms.equals(valueObject.getNotNtsms())) {
            return (false);
        }
        if (this.notNttgk == null) {
            if (valueObject.getNotNttgk() != null) {
                return (false);
            }
        } else if (!this.notNttgk.equals(valueObject.getNotNttgk())) {
            return (false);
        }
        if (this.notWrsms == null) {
            if (valueObject.getNotWrsms() != null) {
                return (false);
            }
        } else if (!this.notWrsms.equals(valueObject.getNotWrsms())) {
            return (false);
        }
        if (this.notWrtgk == null) {
            if (valueObject.getNotWrtgk() != null) {
                return (false);
            }
        } else if (!this.notWrtgk.equals(valueObject.getNotWrtgk())) {
            return (false);
        }
        if (this.notAlsms == null) {
            if (valueObject.getNotAlsms() != null) {
                return (false);
            }
        } else if (!this.notAlsms.equals(valueObject.getNotAlsms())) {
            return (false);
        }
        if (this.notAltgk == null) {
            if (valueObject.getNotAltgk() != null) {
                return (false);
            }
        } else if (!this.notAltgk.equals(valueObject.getNotAltgk())) {
            return (false);
        }

        return true;
    }

    /**
     * toString will return String object representing the state of this
     * valueObject. This is useful during application development, and possibly
     * when application is writing object states in textlog.
     */
    public String toString() {
        StringBuffer out = new StringBuffer(this.getDaogenVersion());
        out.append("\nclass Hnotis, mapping to table MTKN.HNOTIS\n");
        out.append("Persistent attributes: \n");
        out.append("notStatf = " + this.notStatf + "\n");
        out.append("notAkaun = " + this.notAkaun + "\n");
        out.append("notNonot = " + this.notNonot + "\n");
        out.append("notTknot = " + this.notTknot + "\n");
        out.append("notTmpoh = " + this.notTmpoh + "\n");
        out.append("notAmaun = " + this.notAmaun + "\n");
        out.append("notGenap = " + this.notGenap + "\n");
        out.append("notCtsms = " + this.notCtsms + "\n");
        out.append("notCttgk = " + this.notCttgk + "\n");
        out.append("notDnsms = " + this.notDnsms + "\n");
        out.append("notDntgk = " + this.notDntgk + "\n");
        out.append("notNtsms = " + this.notNtsms + "\n");
        out.append("notNttgk = " + this.notNttgk + "\n");
        out.append("notWrsms = " + this.notWrsms + "\n");
        out.append("notWrtgk = " + this.notWrtgk + "\n");
        out.append("notAlsms = " + this.notAlsms + "\n");
        out.append("notAltgk = " + this.notAltgk + "\n");
        return out.toString();
    }

    /**
     * Clone will return identical deep copy of this valueObject. Note, that
     * this method is different than the clone() which is defined in
     * java.lang.Object. Here, the retuned cloned object will also have all its
     * attributes cloned.
     */
    public Object clone() {
        Hnotis cloned = new Hnotis();

        if (this.notStatf != null) {
            cloned.setNotStatf(new String(this.notStatf));
        }
        if (this.notAkaun != null) {
            cloned.setNotAkaun(new String(this.notAkaun));
        }
        if (this.notNonot != null) {
            cloned.setNotNonot(new String(this.notNonot));
        }
        if (this.notTknot != null) {
            cloned.setNotTknot(new String(this.notTknot));
        }
        if (this.notTmpoh != null) {
            cloned.setNotTmpoh(new String(this.notTmpoh));
        }
        if (this.notAmaun != null) {
            cloned.setNotAmaun(new String(this.notAmaun));
        }
        if (this.notGenap != null) {
            cloned.setNotGenap(new String(this.notGenap));
        }
        if (this.notCtsms != null) {
            cloned.setNotCtsms(new String(this.notCtsms));
        }
        if (this.notCttgk != null) {
            cloned.setNotCttgk(new String(this.notCttgk));
        }
        if (this.notDnsms != null) {
            cloned.setNotDnsms(new String(this.notDnsms));
        }
        if (this.notDntgk != null) {
            cloned.setNotDntgk(new String(this.notDntgk));
        }
        if (this.notNtsms != null) {
            cloned.setNotNtsms(new String(this.notNtsms));
        }
        if (this.notNttgk != null) {
            cloned.setNotNttgk(new String(this.notNttgk));
        }
        if (this.notWrsms != null) {
            cloned.setNotWrsms(new String(this.notWrsms));
        }
        if (this.notWrtgk != null) {
            cloned.setNotWrtgk(new String(this.notWrtgk));
        }
        if (this.notAlsms != null) {
            cloned.setNotAlsms(new String(this.notAlsms));
        }
        if (this.notAltgk != null) {
            cloned.setNotAltgk(new String(this.notAltgk));
        }
        return cloned;
    }

    /**
     * getDaogenVersion will return information about generator which created
     * these sources.
     */
    public String getDaogenVersion() {
        return "DaoGen version 2.4.1";
    }

}
